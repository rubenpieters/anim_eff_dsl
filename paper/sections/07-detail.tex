\section{The DSL in Detail}
\label{sec:detail}

The DSL is based on mtl-style effects, which derives its name from the Haskell \texttt{mtl} library\footnote{\url{http://hackage.haskell.org/package/mtl}} implementing monadic effects using typeclasses \cite{DBLP:conf/afp/Jones95}. The DSL also incorporates interpretable (non-monadic) effects as seen in previous approaches \cite{DBLP:journals/corr/abs-1905-06544} \cite{DBLP:conf/icfp/Lindley14}.

\subsection{Specifying Basic Animations}

Mtl-style effects are based on typeclasses defining the available operations for a particular effect. For example, we specify the \hs{basic} operation using the following typeclass.

\begin{code}
class Basic obj f where
  basic :: Traversal' obj Float -> Duration -> Target -> f ()
\end{code}

Note that in traditional mtl-style, we would write the class definition as \hs{class Monad f => Basic obj f}. However, this constraint is not necessarily true for our DSL since we want to provide inspectable animations. The inspection capabilities of monads are limited, so we leave the class of effect open to leave the possibility for a different constraint.

Using the \hs{basic} function created by the \hs{Basic} typeclass enables us to specify basic animations. Now we can accompany the \hs{menuSlideIn} and \hs{appFadeOut} animations from Section~\ref{sec:motivation} with their type annotations.

\begin{code}
menuSlideIn :: (Basic MenuWorld f) => f ()
menuSlideIn = basic (menu . x :: Traversal' MenuWorld Float) (For 0.5) (To 25)

appFadeOut :: (Basic MenuWorld f) => f ()
appFadeOut = basic (obscuringBox . alpha :: Traversal' MenuWorld Float) (For 0.5) (To 0.6)
\end{code}

\begin{code}
indicatorAnimation :: (Basic GameWorld f) => f ()
indicatorAnimation = basic (undefined :: Traversal' GameWorld Float) (For 0.5) (To 25)

characterMove :: (Basic GameWorld f) => f ()
characterMove = basic (undefined :: Traversal' GameWorld Float) (For 0.5) (To 0.6)
\end{code}


\subsection{Specifying Composed Animations}

Before we define the \hs{seq} and \hs{par} functions in their corresponding classes, we take a look at how general we want the functions to be.

Based on the use of the functions in Section~\ref{sec:motivation}, the type of both \hs{seq} and \hs{par} should be \hs{f}~\hs{()}~\hs{->}~\hs{f ()}~\hs{->}~\hs{f}~\hs{()}. However, if we decide to implement these functions in this way we will be restricted to operations which do not return values. Instead, we generalize these functions to \hs{(}\hs{a}~\hs{->}~\hs{b}~\hs{->}~\hs{c}\hs{)}~\hs{->}~\hs{f}~\hs{a}~\hs{->}~\hs{f}~\hs{b}~\hs{->}~\hs{f}~\hs{c}, which takes two operations returning values of respectively type \hs{a} and \hs{b} and a function which combines these return values. The result is then an operation returning a value of type \hs{c}.

\subsubsection{Sequential Composition}

The \hs{seq} function is a specialization of the \hs{liftA2} function from the \hs{Applicative} typeclass. In fact, the whole hierarchy of \hs{Functor}-\hs{Applicative}-\hs{Monad} is sensible to reuse for our use case.

First, we define the \hs{seq} function which works on actions without return value, then we can give a type signature to the \hs{playerMoveAnimation} definition.

\begin{code}
seq :: (Applicative f) => f () -> f () -> f ()
seq f1 f2 = liftA2 (\_ _ -> ()) f1 f2

playerMoveAnimation :: (Applicative f, Basic GameWorld f) => f ()
playerMoveAnimation = indicatorAnimation `seq` characterMove
\end{code}

\subsubsection{Parallel Composition}

The \hs{par} function does not correspond to any function in an existing Haskell typeclass. At first we might suspect to find something in the \hs{Alternative} class, but there is no sensible implementation for \hs{mzero} and the potential laws do not make sense for animations.

Instead, we create our own \hs{Par} typeclass defined below. The function \hs{liftP2} has the same signature as \hs{liftA2}, but its semantics are parallel composition instead of sequential composition. We define the specialized \hs{par} function for effect with no return value, and then we can give a type signature to the \hs{menuAnimation} definition.

\begin{code}
class Par f where
  liftP2 :: (a -> b -> c) -> f a -> f b -> f c

par :: (Par f) => f () -> f () -> f ()
par f1 f2 = liftP2 (\_ _ -> ()) f1 f2

menuAnimation :: (Par f, Basic MenuWorld f) => f ()
menuAnimation = menuSlideIn `par` appFadeOut
\end{code}

\subsection{Running Animations}

To interpret our DSL into an actual animation we need to provide a data type which implements the typeclasses from the previous sections. There are different choices depending on how we expect our animations to be used. We will implement a straightforward model of animations.

An animation takes in the current state of our application and the amount of time elapsed since the previous frame, as a result we obtain the next state of the application and the remaining part of the animation --- or the result of the animation if it is finished. Note that the result is wrapped in a type constructor \hs{m} since we can embed custom effects. This is modeled with the type \hs{obj}~\hs{->}~\hs{Float}~\hs{->}~\hs{(obj,}~\hs{m}~\hs{(Either}~\hs{(Animation}~\hs{obj}~\hs{a)}~\hs{a))}. This is mostly fine, except that we also need to return the remaining duration of the time that is unused. We need this when, for example, we are at the end of an animation and the time between frames is longer than that animation. Then, this remaining duration can be used to see how much of the next animation we need to run. Thus, we get the following definition for which we need to provide an instance for each of the type classes \hs{Basic}, \hs{Monad} and \hs{Par}.

\begin{code}
newtype Animation obj m a = Animation {
  runAnimation ::
    obj -> -- previous state
    Float -> -- time delta
    m -- result is wrapped in m
      ( obj -- next state
      , Either
          (Animation obj m a) -- animation remainder
          a -- animation result
      , Maybe Float -- remaining time delta
      )
}
\end{code}

\subsubsection{Basic Instance}

In the implementation for the \hs{basic} function we do three main things: construct the new object state, calculate the remainder of the animation, and calculate the remaining duration of the frame time. The new object state is created by applying the helper function \hs{updateValue} on the old state via the traversal. The remaining animation and duration are both dependent on a condition. If the current duration minus the frame time is bigger than zero, then there is a remainder for this basic animation and all time delta is used up. If it is not bigger than zero, then this basic animation is finished playing and there is still remaining time delta.

\begin{code}
instance (Applicative m) => Basic obj (Animation obj m) where
  basic traversal (For duration) (To target) =
    Animation $ \obj t -> let
    -- construct new object state
    newObj = over traversal (updateValue t duration target) obj
    -- calculate remaining duration of this basic animation
    newDuration = duration - t
    -- create remainder animation / time delta
    (remainingAnim, remainingDelta) =
      if newDuration > 0
      then ( Left (basic traversal (For newDuration) (To target))
           , Nothing
           )
      else (Right (), Just (-newDuration))
    in pure (newObj, remainingAnim, remainingDelta)
\end{code}

The \hs{updateValue} helper function updates the value within the traversal depending on the time delta, duration and target value. The result value is clamped to make sure we do not overshoot the target when the time delta is larger than the remaining duration of the animation.

\begin{code}
updateValue ::
  Float -> -- time delta
  Float -> -- duration
  Float -> -- target value
  Float -> -- current value
  Float -- new value
updateValue t duration target current = let
  speed = (target - current) * t / duration
  newValue = current + speed
  in if target > current
    then min target newValue
    else max target newValue
\end{code}

\subsubsection{Monad Instance}

In the \hs{Monad} instance, we define how animations run in sequence.

\begin{code}
instance (Monad m) => Monad (Animation obj m) where
  return a = Animation $ \obj t -> return (obj, Right a, Just t)
  (Animation f) >>= k = Animation $ \obj t -> do
    (newObj, animResult, mRemainingDelta) <- f obj t
    case (animResult, mRemainingDelta) of
      (Left anim, Nothing) ->
        return (newObj, Left (anim >>= k), Nothing)
      (Right a, Nothing) ->
        return (newObj, Left (k a), Nothing)
      (Left anim, Just remainingDelta) ->
        runAnimation (anim >>= k) newObj remainingDelta
      (Right a, Just remainingDelta) ->
        runAnimation (k a) newObj remainingDelta
\end{code}

\subsubsection{Par Instance}

In the \hs{Par} instance, we define how animations run in parallel.

\begin{code}
instance (Monad m) => Par (Animation obj m) where
  liftP2 combine (Animation f1) (Animation f2) =
    Animation $ \obj t -> do
    (obj1, remAnim1, mRem1) <- f1 obj t
    (obj2, remAnim2, mRem2) <- f2 obj1 t
    let newRem = case (mRem1, mRem2) of
          (Nothing, _) -> Nothing
          (_, Nothing) -> Nothing
          (Just rem1, Just rem2) -> Just (min rem1 rem2)
    let newAnim = case (remAnim1, remAnim2) of
          (Right a, Right b) ->
            Right (combine a b)
          (Left aniA, Right b) ->
            Left (fmap (\a -> combine a b) aniA)
          (Right a, Left aniB) ->
            Left (fmap (\b -> combine a b) aniB)
          (Left aniA, Left aniB) ->
            Left (liftP2 combine aniA aniB)
    return (obj2, newAnim, newRem)
\end{code}

\subsubsection{Examples}

TODO: examples of running animations by linking with gloss?

\subsection{Inspecting Animations}

Inspecting an animation is done by interpreting the DSL to a \emph{different} data type, which provides instances for the typeclasses with different semantics. This section provides the example of calculating the duration of an animation.

\subsubsection{Inspecting Basic}

The data type we utilize for inspection is the \hs{Const} functor, defined below.

\begin{spec}
newtype Const a b = Const { getConst :: a }
\end{spec}

To inspect animations we provide an instance for the operations which interprets them into this data type. In the case of the \hs{basic} operation, we embed the duration within a \hs{Const} wrapper.

\begin{code}
instance Basic obj (Const Duration) where
  basic _ duration _ = Const duration
\end{code}

\subsubsection{Inspecting Applicative}

While the \hs{Const} data type does not provide a \hs{Monad} instance, it does provide an \hs{Applicative} instance. This means that it is not possible to inspect animations with a \hs{Monad} constraint, but it is possible for animations with an \hs{Applicative} constraint.

\subsubsection{Inspecting Par}

The duration of two animations in parallel is equal to the highest duration of the two. The \hs{Par} instance implementation for \hs{Const Duration} reflects this idea. 

\begin{code}
instance Par (Const Duration) where
  liftP2 _ (Const x1) (Const x2) = Const (max x1 x2)
\end{code}

\subsubsection{Examples}

The duration function is a specialization of the unwrapper function of the \hs{Const} data type, namely \hs{getConst}. We can feed our previously defined animations to this function and obtain the duration of the animations as a result.

\begin{code}
duration :: Const Duration a -> Duration
duration = getConst

playerMoveAnimDuration :: Duration
playerMoveAnimDuration = duration playerMoveAnimation
-- playerMoveAnimDuration = For 1.0

menuAnimDuration :: Duration
menuAnimDuration = duration menuAnimation
-- menuAnimDuration = For 0.5
\end{code}

When we try to retrieve the duration of an animation with a monad constraint, we receive an error from the compiler: it cannot find a \hs{Monad} instance for \hs{Const Duration}.

\begin{spec}
compAnimDuration :: Duration
compAnimDuration = duration complicatedAnimation
-- No instance for (Monad (Const Duration))
\end{spec}
