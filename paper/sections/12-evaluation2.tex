\subsection{Use Case}

This section compares an implementation of a simplified pacman game in Haskell with \dsl{} and TypeScript with GSAP both quantitatively and qualitatively. The quantitative evaluation consists of a relative comparison of lines of code (LOC) for each of the application concerns. The qualitative compares different aspects of the animation libraries.

\subsection{Quantitative Evaluation}

-- table: LOC in modules

\subsection{Qualitative Evaluation}

This section compares PaSe and GSAP with respect to certain criteria. The criteria we consider are:

\begin{itemize}
\item \textbf{Eco-system} Animations are not created in isolation, there needs to be coupling to a graphical backend to display them on the screen. The GSAP library is well integrated with the browser. It supports a rich set of features such as a variety of plugins, compatibility across browsers and support for tweening a large range of properties. It is clear that the maturity of GSAP makes it a clear winner in this regard. For the pacman use case, the use of lenses sufficed to target properties of our self-defined state data type.
\item \textbf{Workflow} When creating animations it is important that they can be specified easily and in a concise manner. Creating pure animations, without any embedded effects, are equally convenient in GSAP as in PaSe. However, more complex interactions with effects and control flow are simpler in PaSe. We encountered this in the pacman use case when implementing particle animations. A particle animation is an animation which creates an object, applies an animation on it, and after that animation that object is destroyed. We implemented a general wrapper for such animations which takes as input a function \hs{Int -> Animation}, where the \hs{Int} is the unique particle identifier, and a creation and deletion function for the particle. In the GSAP library we have to add the function to the timeline as a callback, which results in the duration being considered as \hs{0}. However, the deletion of the particle should occur after the particle animation. This means that we are forced to manually calculate and provide the duration for the particle animation.
\item \textbf{Performance} In the pacman use case, both libraries function equally acceptable for a game application. We have also implemented a benchmark similar to GSAP's speed test\footnote{\url{https://greensock.com/js/speed.html}}. This test benchmarks animations with a large amount of parallel components.
\end{itemize}
