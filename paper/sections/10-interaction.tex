\section{Interaction Between Inspectability and Expressivity}
\label{sec:interaction}

A Haskell DSL is typically a monadic one due to the expressive power of the \hs{>>=} combinator. However, this power also hinders the inspectability of \dsl{}. In this section we take a look at an example of balancing the wanted expressiveness versus inspectability by introducing custom combinators.

We revisit the \hs{onlyDone} animation from Section~\ref{sec:customcomb}. The following definition imposes a \hs{Monad} constraint on \hs{f}, making the animation non-inspectable.

\begin{spec}
onlyDone :: (LinearTo Application f, Get Application f,
  Set Application f, Monad f, Parallel f) => f ()
onlyDone = do
  cond <- doneItemsGt0
  if cond then onlyDoneNaive else hideNotDone
\end{spec}

However, it does seem like we should be able to extract some duration related information from it. For example, the maximum duration should be the highest of the duration of both branches.

To express this idea using \dsl{} we need to introduce an explicit combinator for the constructions which were expressed using the \hs{>>=} cominator. In this case this is the \hs{if-then-else} construction, for which we create a new custom combinator. This is the \hs{handle} combinator from the \hs{DynamicIdiom} class \cite{DBLP:phd/ethos/Yallop10} and the \hs{ifS} combinator from the \hs{Selective} class \cite{Mokhov:2019:SAF:3352468.3341694}.

\begin{code}
class IfThenElse f where
  ifThenElse :: f Bool -> f a -> f a -> f a
\end{code}

In the instance for \hs{Animation}, we can use the implementation dependent on the \hs{>>=} combinator. So, we retrieve the value inside \hs{f}~\hs{Bool} and decide on this value whether to continue with the \texttt{then} branch or the \texttt{else} branch.

\begin{code}
instance (Monad f) => IfThenElse (Animation obj f) where
  ifThenElse fBool thenBranch elseBranch = do
    bool <- fBool
    if bool then thenBranch else elseBranch
\end{code}

Now, we can express the inspectable version of \hs{onlyDone} by using the \hs{ifThenElse} combinator.

\begin{code}
onlyDone :: (LinearTo Application f, Get Application f,
  Set Application f, Applicative f, Parallel f, IfThenElse f)
  => f ()
onlyDone = ifThenElse doneItemsGt0
  (do showAll ; hideNotDone)
  (hideNotDone)
\end{code}

To retrieve the maximum duration, we use a different \hs{newtype} definition, \hs{MaxDuration}, to signify that we are not simply calculating the duration of the animation. In the instance definition for \hs{IfThenElse} we retrieve the durations of the \texttt{then} and \texttt{else} branches and add the higher value to the duration of the preceding animation inside the condition.

\begin{code}
instance IfThenElse (Const MaxDuration) where
  ifThenElse (Const (MaxDur durCondition))
             (Const (MaxDur durThen))
             (Const (MaxDur durElse)) =
    Const (MaxDur (durCondition + max durThen durElse))
\end{code}

Now, we can retrieve the maximum duration of the \hs{onlyDone} animation.

\begin{spec}
menuIntroDuration :: Duration
menuIntroDuration = duration menuIntro
-- menuIntroDuration = MaxFor 1.0
\end{spec}
