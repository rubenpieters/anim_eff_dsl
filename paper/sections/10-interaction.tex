\section{Interaction Between Inspectability and Expressivity}
\label{sec:interaction}

Haskell DSLs are typically monadic because the \hs{>>=} combinator provides
great expressive power. Yet, this power also hinders inspectability. This section shows how to balance 
expressiveness and inspectability with a custom combinator.

Let us revisit the \hs{onlyDone} animation from Section~\ref{sec:customcomb}. The following definition imposes a \hs{Monad} constraint on \hs{f}, making the animation non-inspectable.

\begin{spec}
onlyDone :: (LinearTo Application f, Get Application f,
  Set Application f, Monad f, Parallel f) => f ()
onlyDone = do
  cond <- doneItemsGt0
  if cond then onlyDoneNaive else hideNotDone
\end{spec}

However, it does seem like we should be able to extract some duration related
information from it. For example, the maximum duration should be the largest
duration of the two branches.

To express this idea in \dsl{} we introduce an explicit combinator to replace
the particular use of \hs{>>=}, namely an \hs{if-then-else} construction. 

\begin{code}
class IfThenElse f where
  ifThenElse :: f Bool -> f a -> f a -> f a
\end{code}

This is similar to the \hs{handle} combinator from the \hs{DynamicIdiom} class
\cite{DBLP:phd/ethos/Yallop10} and the \hs{ifS} combinator from the
\hs{Selective} class \cite{Mokhov:2019:SAF:3352468.3341694}.

Now we can reformulate \hs{onlyDone} in terms of this \hs{ifThenElse} combinator.

\begin{code}
onlyDone :: (LinearTo Application f, Get Application f,
  Set Application f, Applicative f, Parallel f, IfThenElse f)
  => f ()
onlyDone = ifThenElse doneItemsGt0
  (do showAll ; hideNotDone)
  (hideNotDone)
\end{code}

Not much changes for \hs{Animation}, which implements \hs{ifThenElse} in terms of
the \hs{>>=} combinator. 

\begin{code}
instance (Monad f) => IfThenElse (Animation obj f) where
  ifThenElse fBool thenBranch elseBranch = do
    bool <- fBool
    if bool then thenBranch else elseBranch
\end{code}

What is new is that we can now also retrieve the maximum duration, using a new type
\hs{MaxDuration} to signify that we are not simply calculating the duration of
the animation. The instance for \hs{IfThenElse} retrieves the
durations of the \texttt{then} and \texttt{else} branches and adds the greater
value to the duration of the preceding animation inside the condition.

\begin{code}
instance IfThenElse (Const MaxDuration) where
  ifThenElse (Const (MaxDur durCondition))
             (Const (MaxDur durThen))
             (Const (MaxDur durElse)) =
    Const (MaxDur (durCondition + max durThen durElse))
\end{code}

This allows us to retrieve the maximum duration of the \hs{onlyDone} animation.

\begin{spec}
onlyDoneMaxDuration :: MaxDuration
onlyDoneMaxDuration = maxDuration onlyDone
-- onlyDoneMaxDuration = MaxDur 1.0
\end{spec}
