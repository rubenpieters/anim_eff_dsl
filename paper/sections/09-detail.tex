\section{Implementation of \dsl{}}
\label{sec:detail}

This section implements the earlier introduced operations and redefines the animations to show the resulting type signature. We
develop \dsl{} in the style of the \texttt{mtl}
library\footnote{\url{http://hackage.haskell.org/package/mtl}} which implements
monadic effects using typeclasses \cite{DBLP:conf/afp/Jones95}.  This style is
also called the finally tagless approach \cite{DBLP:journals/jfp/CaretteKS09}.
However, because the \dsl{} classes are not subclasses of \hs{Monad} they leave
room for inspectability.

\subsection{Specifying Basic Animations}

The \texttt{mtl} library uses typeclasses to declare the basic operations of an
effect. Similarly, we specify the \hs{linearTo} operation using
the \hs{LinearTo} typeclass.

\begin{code}
class LinearTo obj f where
  linearTo :: Traversal' obj Float -> Duration -> Target -> f ()
\end{code}

The traditional mtl-style would add a \hs{Monad f} superclass constraint. Yet,
because it hinders inspectability, we do not require it everywhere. Instead,
while we can still choose to add an additional \hs{Monad f} constraint in selected
cases, we leave the freedom to opt foran alternative like \hs{Applicative f} in
other cases.

The \hs{linearTo} function of the \hs{LinearTo} typeclass specifies basic
animations like \hs{line1Out}, \hs{line2In},
\hs{menuSlideIn}, and \hs{appFadeOut} animations from
Section~\ref{sec:motivation}. 
As an example, we redefine \hs{line1Out} with its type signature; the others 
are similar. 

\begin{code}
line1Out :: (LinearTo Application f) => f ()
line1Out = linearTo (navbar . underline1 . width) (For 0.25) (To 0)
\end{code}

\subsection{Specifying Composed Animations}

Section~\ref{sec:motivation} used the combinators \hs{sequential} and
\hs{parallel} for composing animations. Here, we provide these as well as more
general combinators.


% to
% \hs{(}\hs{a}~\hs{->}~\hs{b}~\hs{->}~\hs{c}\hs{)}~\hs{->}~\hs{f}~\hs{a}~\hs{->}~\hs{f}~\hs{b}~\hs{->}~\hs{f}~\hs{c},
% which takes two animations returning values of respectively type \hs{a} and
% \hs{b} and a function that combines these return values. The result is then an
% animation returning a value of type \hs{c}.

\subsubsection{Sequential Composition}

We reuse the \hs{Functor}-\hs{Applicative}-\hs{Monad} hierarchy for
sequencing animations. In particular, the \hs{sequential} function is a
specialization of the \hs{liftA2}
function\footnote{\url{https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html\#v:liftA2}}.

\begin{code}
sequential :: (Applicative f) => f () -> f () -> f ()
sequential f1 f2 = liftA2 (\_ _ -> ()) f1 f2
\end{code}

Hence, the type signature for \hs{selectBtn2Anim} contains an 
\hs{Applicative f} constraint in addition to the \hs{LinearTo Application f}
constraint.

\begin{code}
selectBtn2Anim :: (LinearTo Application f, Applicative f) => f ()
selectBtn2Anim = line1Out `sequential` line2In
\end{code}

\subsubsection{Parallel Composition}

The \hs{parallel} function does not correspond to a member function in an
existing Haskell typeclass. At first we might consider the \hs{<|>} combinator
in the \hs{Alternative} class, but there is no sensible corresponding
\hs{empty} animation; also the suggested 
laws\footnote{\url{https://en.wikibooks.org/wiki/Haskell/Alternative_and_MonadPlus}}
do not make sense for animations.

Instead, we create our own \hs{Parallel} typeclass below. Its function
\hs{liftP2} has the same signature as \hs{liftA2}, but denotes
parallel composition instead of sequential composition. The
\hs{parallel} function is a specialization of \hs{liftP2}.

\begin{code}
class Parallel f where
  liftP2 :: (a -> b -> c) -> f a -> f b -> f c

parallel :: (Parallel f) => f () -> f () -> f ()
parallel f1 f2 = liftP2 (\_ _ -> ()) f1 f2
\end{code}
 and
Now we can give a type signature for \hs{menuIntro}.
\begin{code}
menuIntro :: (LinearTo Application f, Parallel f) => f ()
menuIntro = menuSlideIn `parallel` appFadeOut
\end{code}

\subsection{Running Animations}

Now we create a new \hs{Animation} datatype that instantiates the above
typeclasses to interpret \dsl{} programs as actual animations. We briefly
summarize this implementation here and refer for more details to
our prototype
implementation.\footnote{\url{https://github.com/rubenpieters/anim_eff_dsl/tree/master/code}}

The function type
\hs{obj}~\hs{->}~\hs{Float}~\hs{->}~\hs{m}~\hs{(}\hs{obj,}~\hs{(Either}~\hs{(Animation}~\hs{obj}~\hs{a)}~\hs{a))}
models an animation.
It takes as inputs the the current application state and the
time elapsed since the previous frame. As output it produces a new
application state for the next frame together with either the remainder of the animation or, if there is no remainder, the result of
the animation. Note that the output is wrapped in a type
constructor \hs{m} to embed custom effects. 
One more detail is missing in the output: the remaining unused time. We need
this when, for example, there is more time between frames than the animation
uses.
Then, the remaining time
can be used to run part of the next animation. All together, we get
the following type definition.

\begin{code}
newtype Animation obj m a = Animation { runAnimation ::
    obj ->                           -- previous state
    Float ->                         -- time delta
    m ( obj                          -- next state
      , Either (Animation obj m a) a -- remainder / result
      , Maybe Float )}               -- remaining time delta
\end{code}

\subsubsection{LinearTo Instance}

The \hs{linearTo} implementation of \hs{Animation} does three things: construct
the new object state, calculate the remainder of the animation, and calculate
the unused time. The difference between the \hs{linearTo} duration and the
frame time determines whether there is a remaining \hs{linearTo} animation or
remaining time.

\paragraph{Examples}

Let us illustrate the behaviour on a simple application
state that is a tuple, \hs{type State = (Float, Float)}, of an {x}-value and a {y}-value.
The \hs{right} animation transforms the \hs{x}-value to 50 over a time of 1
second.

\begin{code}
right :: (LinearTo State f) => f ()
right = linearTo x (For 1) (To 50)
\end{code}

We run the animation for 0.5 seconds by applying the \hs{runAnimation} function
on \hs{right}, together with the initial state (\hs{s0 =
(0,0)}) and the duration \hs{0.5}. We also instantiate the \hs{m} type constructor \hs{m} inside
the \hs{Animation} data type with \hs{Identity} as no additional effects are
needed; this means that the result can be unwrapped with
\hs{runIdentity}.

\begin{code}
(s1, remAn1, remDel1) = runIdentity (runAnimation right s0 0.5)
-- s1 = (25.0, 0.0) | remAn1 = Left anim2 | remDel1 = Nothing
\end{code}

Running \hs{right} for 0.5 seconds uses all available time and yields the new state
\hs{(25, 0)}. The remainder of
the animation is the \hs{right} animation with its duration reduced by \hs{0.5}, or essentially \hs{linearTo x (For 0.5) (To 50)}. Let us run this
remainder for 1 second.

\begin{code}
(s2, remAn2, remDel2) = runIdentity (runAnimation anim2 s1 1)
-- s2 = (50.0, 0.0) | remAn2 = Right () | remDel2 = Just 0.5
\end{code}

Now the animation finishes in state \hs{(50, 0)} with result \hs{()} and remaining time \hs{0.5}.

\subsubsection{Monad Instance}

For sequential animations we provide a \hs{Monad} instance. Its \hs{return} embeds the
result \hs{a} inside the \hs{Animation} data type. The essence of the
\hs{f}~\hs{>>=}~\hs{k} case is straightforward: first, run the animation
\hs{f}, then pass its result to the continuation \hs{k} and run that animation.
Of course, running \hs{f} does not necessarily give us a result \hs{a}. Running
an animation gives us either a result or an animation remainder; we also have
to take into account the potential remaining time. When we have an
animation remainder instead of a result, we need to repackage this remaining
animation as \hs{remainder}~\hs{>>=}~\hs{k} instead of using \hs{k}~\hs{a}.
Additionally, if there is no remaining time,  we do not continue
running the continuation and instead return the current state and animation
remainder.

\paragraph{Examples}

Let us define an additional animation \hs{up} which transforms the \hs{y}-value to 50 over a duration of 1 second. Additionally, we define an animation \hs{rightThenUp} which composes the \hs{right} and \hs{up} animations in sequence.

\begin{code}
up :: (LinearTo State f) => f ()
up = linearTo y (For 1) (To 50)

rightThenUp :: (LinearTo State f, Applicative f) => f ()
rightThenUp = right `sequential` up
\end{code}

Running the \hs{rightThenUp} animation for 0.5 seconds gives a similar result
to running \hs{right} for 0.5 seconds. We obtain the new state \hs{(25,
0)}, an animation remainder \hs{anim2} and there is no remaining time.
Now the animation remainder is the rest of the \hs{rightThenUp} animation,
which is half of the \hs{right} animation and the full \hs{up} animation. So,
when we run this animation remainder for 1 second, it will run the second half
of \hs{right} and the first half of \hs{up}.  This results in the state
\hs{(50, 25)}, the animation remainder \hs{anim3} and no remaining delta time.
This animation remainder is of course the second half of the \hs{up} animation.
If we continue to run that remainder, for example for 1 second, then we get the
final state \hs{(50, 50)} and the animation result \hs{()}.

\subsubsection{Parallel Instance}

For parallel animations the \hs{liftP2} implementation runs
the animations \hs{f1} and \hs{f2} both on the starting
state. We distinguish different cases depending on whether \hs{f1} and
\hs{f2} finish with a result or an animation remainder, and the remaining
time. We check which of the animations have finished and repackage them
either into a result or a new remainder, using the result combination function
where appropriate. To decide whether to continue running the animation, we
check if the lowest of the two remaining times is nonzero since that means the
longest of the two animations was not able to utilize the full delta time.

\paragraph{Examples}

Let us run the animations \hs{right} and \hs{up} in parallel, which means
that both the \hs{x} and \hs{y}-value will increase simultaneously.

\begin{code}
rightAndUp :: (LinearTo State f, Parallel f) => f ()
rightAndUp = right `parallel` up
\end{code}

The result of running this animation for 0.5 seconds gives the state \hs{(25,
25)} and no remaining time. If we continue the animation
remainder we get the state \hs{(50, 50)} and 0.5 seconds of remaining 
time.

\subsection{Inspecting Animations}

Inspecting an animation is done by interpreting \dsl{} to a different data
type, which provides instances for the typeclasses with different semantics.
In particular we show how to inspect the duration of an animation
by means of the \hs{Const} functor.

\begin{spec}
newtype Const a b = Const { getConst :: a }
\end{spec}

\subsubsection{Inspecting LinearTo}

To inspect animations we provide an instance for the operations which
interprets them into \hs{Const Duration}. In the case of the \hs{linearTo}
operation, we simply embed the duration within a \hs{Const} wrapper.

\begin{code}
instance LinearTo obj (Const Duration) where
  linearTo _ duration _ = Const duration
\end{code}

\subsubsection{Inspecting Applicative}

While the \hs{Const} data type does not provide a \hs{Monad} instance, it does
provide an \hs{Applicative} instance. This means that it is not possible to
inspect animations with a \hs{Monad} constraint, but it is possible for
animations with an \hs{Applicative} constraint. The \hs{Const} data type is not
the culprit here, but rather the \hs{>>=} method of the \hs{Monad} class which
contains a continuation function \hs{a}~\hs{->}~\hs{m}~\hs{b}, which is the
limiting factor of inspection.

\subsubsection{Inspecting Parallel}

The duration of two parallel animations is the maximum of their durations. 
The \hs{Par} instance implementation for \hs{Const Duration} captures
this. 

\begin{code}
instance Par (Const Duration) where
  liftP2 _ (Const x1) (Const x2) = Const (max x1 x2)
\end{code}

\paragraph{Examples}

The duration function is a specialization of the unwrapper function of the
\hs{Const} data type, namely \hs{getConst}. We can feed our previously defined
animations \hs{selectBtn2Anim} and \hs{menuIntro} from
Section~\ref{sec:motivation} to this function and obtain the duration of the
animations as a result.

\begin{code}
duration :: Const Duration a -> Duration
duration = getConst

selectBtn2AnimDuration :: Duration
selectBtn2AnimDuration = duration selectBtn2Anim -- = For 1.0

menuIntroDuration :: Duration
menuIntroDuration = duration menuIntro -- = For 0.5
\end{code}

When we try to retrieve the duration of an animation with a monad constraint,
we receive an error from the compiler: it cannot find a \hs{Monad} instance for
\hs{Const Duration}.

\begin{spec}
complicatedAnimDuration :: Duration
complicatedAnimDuration = duration complicatedAnim
-- No instance for (Monad (Const Duration))
\end{spec}

\subsection{Adding a Custom Operation}

Adding a custom operation is done as in any other mtl-style approach: by defining a new class for this operation. For example, if we want to add a \hs{set} operation, then we create a corresponding \hs{Set} class.

\begin{code}
class Set obj f where set :: Lens' obj a -> a -> f ()
\end{code}

Now, an animation that uses the \hs{set} operation will incur a \hs{Set} constraint.

\begin{code}
checkIcon :: (Set CompleteIcon f, ...) => f ()
checkIcon = do ...; set (checkmark . color) green; ...
\end{code}

To inspect or run such an animation, we also need to provide instances for the \hs{Animation} and \hs{Const} data types. In the \hs{Animation} instance, we alter the previous state by setting the value targeted by the \hs{lens} to \hs{a}. The duration of a \hs{set} animation is 0, which is what is returned in the \hs{Duration} instance.

\begin{code}
instance (Applicative m) => Set obj (Animation obj m) where
  set lens a = Animation $ \obj t -> let
    newObj = Lens.set lens a obj
    in pure (newObj, Right (), Just t)

instance Set obj (Const Duration) where
  set _ _ = Const (For 0)
\end{code}

This section gave an overview of the features provided by \dsl{}, however combining inspectability while allowing freedom of expressivity is not always straightforward. Therefore, we look at an example of the interaction of these two features in the next section.
