\section{Implementation of \dsl{}}
\label{sec:detail}

This section goes over the definition of the operations used earlier and redefines the animations to show the resulting type signature. We develop \dsl{} in the mtl-style, which derives its name from the Haskell \texttt{mtl} library\footnote{\url{http://hackage.haskell.org/package/mtl}} implementing monadic effects using typeclasses \cite{DBLP:conf/afp/Jones95}. This style is also called the finally tagless approach \cite{DBLP:journals/jfp/CaretteKS09}. However, \dsl{} does not force the monadic constraint on its class definitions and thus provides opportunities for inspectability.

\subsection{Specifying Basic Animations}

Mtl-style effects are based on typeclasses defining the available operations for a particular effect. For example, we specify the \hs{linearTo} operation using the \hs{LinearTo} typeclass defined below.

\begin{code}
class LinearTo obj f where
  linearTo :: Traversal' obj Float -> Duration -> Target -> f ()
\end{code}

Note that in traditional mtl-style, we would write the class definition as \hs{class Monad f => LinearTo obj f}. However, this constraint is not necessarily applicable for our DSL since we want to provide inspectable animations. The inspection capabilities of monads are limited, so we omit the class constraint, which allows other constraints such as \hs{Applicative} to be used as well.

Using the \hs{linearTo} function created by the \hs{LinearTo} typeclass enables us to specify basic animations. Now we can accompany the \hs{line1Outro}, \hs{line2Intro}, \hs{menuSlideIn}, and \hs{appFadeOut} animations from Section~\ref{sec:motivation} with their type signatures. The signature of each animation is \hs{f}~\hs{()}, but with a \hs{LinearTo Application f} constraint. As an example, we redefine \hs{line1Outro} with its type signature. 

\begin{code}
line1Outro :: (LinearTo Application f) => f ()
line1Outro = linearTo (navbar . underline1 . width) (For 0.25) (To 0)
\end{code}

\subsection{Specifying Composed Animations}

We used the combinators \hs{sequential} and \hs{parallel} for creating composed animations. Based on their use in Section~\ref{sec:motivation}, these have the form \hs{f}~\hs{()}~\hs{->}~\hs{f ()}~\hs{->}~\hs{f}~\hs{()}. However, these functions are limited to animations with no interesting return value. Instead, we generalize these functions to \hs{(}\hs{a}~\hs{->}~\hs{b}~\hs{->}~\hs{c}\hs{)}~\hs{->}~\hs{f}~\hs{a}~\hs{->}~\hs{f}~\hs{b}~\hs{->}~\hs{f}~\hs{c}, which takes two animations returning values of respectively type \hs{a} and \hs{b} and a function which combines these return values. The result is then an animation returning a value of type \hs{c}.

\subsubsection{Sequential Composition}

Instead of defining our own class for sequential animations, we reuse the \hs{Functor}-\hs{Applicative}-\hs{Monad} hierarchy intended for sequencing effects. As a result, the \hs{sequential} function becomes a specialization of the \hs{liftA2} function\footnote{\url{https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:liftA2}}.

\begin{code}
sequential :: (Applicative f) => f () -> f () -> f ()
sequential f1 f2 = liftA2 (\_ _ -> ()) f1 f2
\end{code}

The type signature for \hs{selectBtn2Anim} contains an additional \hs{Applicative f} constraint in addition to the \hs{LinearTo Application f} constraint.

\begin{code}
selectBtn2Anim :: (LinearTo Application f, Applicative f) => f ()
selectBtn2Anim = line1Outro `sequential` line2Intro
\end{code}

\subsubsection{Parallel Composition}

The \hs{parallel} function does not correspond to any function in an existing Haskell typeclass. At first we might suspect to find something in the \hs{Alternative} class, but there is no sensible implementation for \hs{mzero} and the potential laws\footnote{\url{https://en.wikibooks.org/wiki/Haskell/Alternative_and_MonadPlus}} do not make sense for animations.

Instead, we create our own \hs{Parallel} typeclass defined below. The function \hs{liftP2} has the same signature as \hs{liftA2}, but its semantics are parallel composition instead of sequential composition. We define the specialized \hs{parallel} function for animations with no return value, and then we can give a type signature to the \hs{menuIntro} definition.

\begin{code}
class Parallel f where
  liftP2 :: (a -> b -> c) -> f a -> f b -> f c

parallel :: (Parallel f) => f () -> f () -> f ()
parallel f1 f2 = liftP2 (\_ _ -> ()) f1 f2

menuIntro :: (LinearTo Application f, Parallel f) => f ()
menuIntro = menuSlideIn `parallel` appFadeOut
\end{code}

\subsection{Running Animations}

To interpret our DSL into an actual animation we need to provide a data type which implements the typeclasses from the previous sections. We give an explanation of our implementation in the following paragraph. The full details can be found in our prototype implementation\footnote{\url{https://github.com/rubenpieters/anim_eff_dsl/tree/master/code}}.

An animation takes in the current state of our application and the amount of time elapsed since the previous frame, as a result we obtain the next state of the application and the remaining part of the animation --- or the result of the animation if it is finished. Note that the result is wrapped in a type constructor \hs{m} since we can embed custom effects. This is modeled with the type \hs{obj}~\hs{->}~\hs{Float}~\hs{->}~\hs{(}\hs{obj,}~\hs{m}~\hs{(Either}~\hs{(Animation}~\hs{obj}~\hs{a)}~\hs{a))}. This seems fine, except that we also need to return the remaining duration of the time that is unused. We need this when, for example, we are at the end of an animation and the delta time between frames is longer than that animation. Then, this remaining duration can be used to see how much of the next animation we need to run. Thus, we get the following definition for which we need to provide an instance for each of the type classes \hs{LinearTo}, \hs{Monad} and \hs{Par}.

\begin{code}
newtype Animation obj m a = Animation { runAnimation ::
    obj ->                    -- previous state
    Float ->                  -- time delta
    m                         -- result is wrapped in m
      ( obj                   -- next state
      , Either
          (Animation obj m a) -- animation remainder
          a                   -- animation result
      , Maybe Float )}        -- remaining time delta
\end{code}

\subsubsection{LinearTo Instance}

In the implementation for the \hs{linearTo} function we do three main things: construct the new object state, calculate the remainder of the animation, and calculate the remaining duration of the frame time. The new object state is created by applying the helper function \hs{updateValue} on the old state via the traversal. The remaining animation and duration are both dependent on a condition. If the current duration minus the frame time is bigger than zero, then there is a remainder for this basic animation and all time delta is used up. If it is not bigger than zero, then this basic animation is finished playing and there is still remaining time delta.

\paragraph{Examples}

To illustrate the behaviour of running animations, we show how the implementation operates in a very simplified setting where the application state is a tuple, \hs{type State = (Float, Float)}. The first component is the \hs{x}-value and the second component the \hs{y}-value. We define a simple animation \hs{moveRight} which transforms the \hs{x}-value to 50 over a time of 1 second.

\begin{code}
moveRight :: (LinearTo State f) => f ()
moveRight = linearTo x (For 1) (To 50)
\end{code}

We run the animation for 0.5 seconds by applying the \hs{runAnimation} function to the animation \hs{moveRight}, together with the initial state (\hs{state0 = (0,0)}) and the duration \hs{0.5}. We set the type constructor \hs{m} inside the \hs{Animation} data type to \hs{Identity} since no additional effects are present, which means that the result has to be unwrapped using \hs{runIdentity}.

\begin{code}
(state1, remAnim1, remDelta1) =
  runIdentity (runAnimation anim1 state0 0.5)
-- state1 = (25.0, 0.0)
-- remAnim1 = Left anim2
-- remDelta1 = Nothing
\end{code}

Running an animation results in a triple containing the new state, the remainder of the animation and the remaining delta time. The new state is \hs{(25, 0)} caused by running half of the \hs{moveRight} animation and the remaining delta is \hs{Nothing} since all delta time is used. The remainder of the animation is the second half of the \hs{moveRight} animation. We run this remainder for 1 second to see what happens when not all delta time can be used by an animation.

\begin{code}
(state2, remAnim2, remDelta2) =
  runIdentity (runAnimation anim2 state1 1)
-- state2 = (50.0, 0.0)
-- remAnim2 = Right ()
-- remDelta2 = Just 0.5
\end{code}

The resulting state is \hs{(50, 0)}, which is the result of running \hs{moveRight} fully, the remaining delta time is \hs{0.5} since only 0.5 seconds were required to finish the animation, and the animation has finished with the result \hs{()}.

\subsubsection{Monad Instance}

For sequential animations, we need a \hs{Monad} instance which in turn requires an implementation for \hs{return} and \hs{>>=}. The \hs{return} embeds the result \hs{a} inside the \hs{Animation} data type. The essence of the \hs{f}~\hs{>>=}~\hs{k} case is straightforward: first, run the animation \hs{f}, then pass its result to the continuation \hs{k} and run that animation. Of course, running \hs{f} does not necessarily give us a result \hs{a}. Running an animation gives us either a result or an animation remainder, plus we have to take into account the potential remaining delta time. When we have an animation remainder instead of a result, we need to repackage this remaining animation as \hs{remainder}~\hs{>>=}~\hs{k} instead of using \hs{k}~\hs{a}. Additionally, if the remaining delta time is finished we do not continue running the continuation and instead return the current state and animation remainder.

\paragraph{Examples}

Now let us define an additional animation \hs{moveUp} which transforms the \hs{y}-value to 50 over a duration of 1 second. Additionally, we define an animation \hs{moveRightThenUp} which composes the \hs{moveRight} and \hs{moveUp} animations in sequence.

\begin{code}
moveUp :: (LinearTo State f) => f ()
moveUp = linearTo y (For 1) (To 50)

moveRightThenUp :: (LinearTo State f, Applicative f) => f ()
moveRightThenUp = moveRight `sequential` moveUp
\end{code}

Running the \hs{moveRightThenUp} animation for 0.5 seconds gives a similar result to simply running \hs{moveRight} for 0.5 seconds. We obtain the new state \hs{(25, 0)}, an animation remainder \hs{anim2} and there is no remaining delta time. Now, the animation remainder is the rest of the \hs{moveRightThenUp} animation, which is half of the \hs{moveRight} animation and the full \hs{moveUp} animation. So, when we run this animation remainder for 1 second, it will run the second half of \hs{moveRight} and the first half of \hs{moveUp}.
This results in the state \hs{(50, 25)}, the animation remainder \hs{anim3} and no remaining delta time. This animation remainder is of course the second half of the \hs{moveUp} animation. If we continue to run that remainder, for example for 1 second, then we get the final state \hs{(50, 50)} and the animation result \hs{()}.

%\begin{code}
%(state2, remAnim2, remDelta2) =
%  runIdentity (runAnimation anim2 state1 1)
%-- state2 = (50.0, 25.0)
%-- remAnim2 = Left anim3
%-- remDelta2 = Nothing
%\end{code}

\subsubsection{Parallel Instance}

For parallel animations, we need to implement the \hs{liftP2} function. In this implementation we run the two animations \hs{f1} and \hs{f2} both on the starting state. Now, there are different combinations possible on whether \hs{f1} and \hs{f2} have finished with a result, there is still an animation remainder, and whether there is a remaining time delta. We check which of the two animations have finished and repackage it either into a result or a new remainder, using the combine function where appropriate. To decide on whether to continue running the animation, we check if the lowest of the two delta times is nonzero since that means the longest of the two animations was not able to utilize the full delta time.

\paragraph{Examples}

Now, we will run the animations \hs{moveRight} and \hs{moveUp} in parallel, which means that both the \hs{x} and \hs{y}-value will be increasing simultaneously.

\begin{code}
moveRightAndUp :: (LinearTo State f, Parallel f) => f ()
moveRightAndUp = moveRight `parallel` moveUp
\end{code}

The result of running this animation for 0.5 seconds gives the state \hs{(25, 25)} and no remaining delta time, if we continue running the obtained animation remainder we get the state \hs{(50, 50)} and 0.5 seconds of remaining delta time.

\subsection{Inspecting Animations}

Inspecting an animation is done by interpreting \dsl{} to a different data type, which provides instances for the typeclasses with different semantics. This section implements support for calculating the duration of an animation.

\subsubsection{Inspecting LinearTo}

The data type we utilize for inspection is the \hs{Const} functor, defined below.

\begin{spec}
newtype Const a b = Const { getConst :: a }
\end{spec}

To inspect animations we provide an instance for the operations which interprets them into this data type. In the case of the \hs{linearTo} operation, we embed the duration within a \hs{Const} wrapper.

\begin{code}
instance LinearTo obj (Const Duration) where
  linearTo _ duration _ = Const duration
\end{code}

\subsubsection{Inspecting Applicative}

While the \hs{Const} data type does not provide a \hs{Monad} instance, it does provide an \hs{Applicative} instance. This means that it is not possible to inspect animations with a \hs{Monad} constraint, but it is possible for animations with an \hs{Applicative} constraint. The \hs{Const} data type is not the culprit here, but rather the \hs{>>=} method of the \hs{Monad} class which contains a continuation function \hs{a}~\hs{->}~\hs{m}~\hs{b}, which is the limiting factor of inspection.

\subsubsection{Inspecting Par}

The duration of two animations in parallel is equal to the highest duration of the two. The \hs{Par} instance implementation for \hs{Const Duration} reflects this idea. 

\begin{code}
instance Par (Const Duration) where
  liftP2 _ (Const x1) (Const x2) = Const (max x1 x2)
\end{code}

\paragraph{Examples}

The duration function is a specialization of the unwrapper function of the \hs{Const} data type, namely \hs{getConst}. We can feed our previously defined animations \hs{selectBtn2Anim} and \hs{menuIntro} from Section~\ref{sec:motivation} to this function and obtain the duration of the animations as a result.

\begin{code}
duration :: Const Duration a -> Duration
duration = getConst

selectBtn2AnimDuration :: Duration
selectBtn2AnimDuration = duration selectBtn2Anim
-- selectBtn2AnimDuration = For 1.0

menuIntroDuration :: Duration
menuIntroDuration = duration menuIntro
-- menuIntroDuration = For 0.5
\end{code}

When we try to retrieve the duration of an animation with a monad constraint, we receive an error from the compiler: it cannot find a \hs{Monad} instance for \hs{Const Duration}.

\begin{spec}
complicatedAnimationDuration :: Duration
complicatedAnimationDuration = duration complicatedAnimation
-- No instance for (Monad (Const Duration))
\end{spec}

\subsection{Adding a Custom Operation}

Adding a custom operation is done as in any other mtl-style approach: by defining a new class containing this operation. For example, if we want to add a \hs{set} operation, then we create a corresponding \hs{Set} class.

\begin{code}
class Set obj f where
  set :: Lens' obj a -> a -> f ()
\end{code}

Now, an animation containing the \hs{set} operation will additionally have a \hs{Set} constraint added to it.

\begin{code}
checkIcon :: (Set CompleteIcon f, ...) => f ()
checkIcon = do ...; set (checkmark . color) completeGreen; ...
\end{code}

To inspect or run such an animation, we also need to provide instances for the \hs{Animation} and \hs{Const} data types. In the \hs{Animation} instance, we alter the previous state by setting the value targeted by the \hs{lens} to \hs{a}. The duration of a \hs{set} animation is 0, which is what is returned in the \hs{Duration} instance.

\begin{code}
instance (Applicative m) => Set obj (Animation obj m) where
  set lens a = Animation $ \obj t -> let
    newObj = Lens.set lens a obj
    in pure (newObj, Right (), Just t)

instance Set obj (Const Duration) where
  set _ _ = Const (For 0)
\end{code}

This section gave an overview of the features provided by \dsl{}, however combining inspectability while allowing freedom of expressivity is not always straightforward. Therefore, we look at an example of the interaction of these two features in the next section.
