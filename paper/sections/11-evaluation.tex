\section{Interaction Between Callbacks and Inspectability}
\label{sec:evaluation}

There are many different JavaScript animation libraries\footnote{Some examples: \url{https://greensock.com}, \url{https://animejs.com/}, and \url{https://popmotion.io}}. Many of these libraries provide callbacks to provide extensibility, by which the user can add custom behaviour the library has not foreseen. However

We take as representative example the GreenSock Animation Platform (GSAP), which is a widely recommended and mature JavaScript animation library providing a variety of features.

\subsection{Working with GSAP}

GSAP provides primitives which are similar to the \hs{basic} and \hs{sequential} operations in \dsl{}. While it does not have a primitive for \hs{parallel} composition, we can implement it using the features provided by GSAP.

In GSAP we can create \texttt{TweenMax} objects, which is similar to the \hs{basic} operation in \dsl{}. The arguments are also similar: a parameter which indicates which object to change, a duration, and the target value for the property. Below we create the animation \texttt{right} which moves \texttt{box1} to the right.

\begin{js}
const right = new TweenMax("#box1", 1, { x: 50 });
\end{js}

Constructing a sequential animation is done by using a timeline. First a timeline is created and we can add animations with the \texttt{add} method. Below, we create the animation \texttt{rightThenDown} which moves \texttt{box1} to the right and then moves it down.

\begin{js}
const rightThenDown = new TimelineMax({ paused: true })
  .add(new TweenMax("#box1", 1, { x: 50 }))
  .add(new TweenMax("#box1", 1, { y: 50 }));
\end{js}

To create an animation which moves both \texttt{box1} and \texttt{box2} in parallel to the right, we do this by supplying the same optional position parameter. If we provide both additions to the timeline with the same static position \texttt{0}, then both animations run in parallel. Below we create a \texttt{both} animation which moves both \texttt{box1} and \texttt{box2} in parallel.

\begin{js}
const both = new TimelineMax({ paused: true })
  .add(new TweenMax("#box1", 1, { x: 50 }), 0)
  .add(new TweenMax("#box2", 1, { x: 50 }), 0);
\end{js}

Since we have specified the option \texttt{paused} to \texttt{true}, we must call the \texttt{play} method to actually run the animation, for example \texttt{rightThenDown.play()}. Using this behaviour, and the ability to nest timelines, we can extract similar functionality as \hs{sequential} and \hs{parallel} in \dsl{}.

\begin{js}
function sequential(tl1, tl2) {
  return new TimelineMax({ paused: true })
    .add(tl1.play())
    .add(tl2.play());
}

function parallel(tl1, tl2) {
  return new TimelineMax({ paused: true })
    .add(tl1.play(), 0)
    .add(tl2.play(), 0);
}
\end{js}

\subsection{Callbacks and Inspectability}

The \texttt{add} method is overloaded to accept callbacks as well. We made use of this in the previous section, since \texttt{tl.play()} was actually shorthand for the callback \texttt{() => tl.play()}. This is how GSAP achieves extensibility, since these callbacks provides us with the capability of embedding arbitrary effects inside any animation.

GSAP also provides features related to inspectability. In fact, it provides a \texttt{totalDuration} method to return the total duration of an animation. However, callbacks and inspectability do not always work nicely together. This section illustrates an example of this.

Animations created with the previously defined \texttt{sequential} and \texttt{parallel} functions correctly give their total duration when queried. For example, we define an animation which moves both boxes in parallel to \texttt{x = 50} and then back to \texttt{x = 0} in parallel. The duration is correctly returned as 2.

\begin{js}
const bothTo50 = parallel(
  new TweenMax("#box1", 1, { x: 50 }),
  new TweenMax("#box2", 1, { x: 50 }));

const bothTo0 = parallel(
  new TweenMax("#box1", 1, { x: 0 }),
  new TweenMax("#box2", 1, { x: 0 }));

const bothAnimation = sequential(bothTo50, bothTo0);

const bothAnimDuration = bothAnimation.totalDuration()
// bothAnimDuration = 2
\end{js}

However, if we want to provide animations similar to \hs{onlyDone}, which contains an \hs{if-then-else} construction, then the duration returned is not what might be expected. For example, if we create a conditional animation \texttt{conditionalAnim}, then it is reported as 1.

\begin{js}
let cond = true;

const conditionalAnim = new TimelineMax({ paused: true })
  .add(bothTo50.play())
  .add(() => { if (cond) { bothTo0.play() } else { bothTo100.play() } });

const conditionalAnimDuration = conditionalAnim.totalDuration()
// conditionalAnimDuration = 1
\end{js}

TODO: expand more on - relevance of duration in other GSAP features which are broken by this - more detail on GSAP features which utilize duration information?
