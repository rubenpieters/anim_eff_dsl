\section{Interaction Between Callbacks and Inspectability}
\label{sec:evaluation}

Many JavaScript animation libraries\footnote{Examples:
\url{https://greensock.com}, \url{https://animejs.com}, and
\url{https://popmotion.io}.} exist, most of which allow the user to add custom
behavior (which the library has not foreseen) through callbacks. A good example
is the GreenSock Animation Platform (GSAP), a widely recommended and mature
JavaScript animation library with a variety of features.

\subsection{Working with GSAP}

GSAP provides primitives similar to the \hs{linearTo} and
\hs{sequential} operations in \dsl{}. While it does not have a primitive for
\hs{parallel} composition, we can define it in terms of other GSAP features.

\texttt{TweenMax} objects are the GSAP counterpart of the
\hs{linearTo} operation. Their arguments are similar: the object to change, the
duration, and the target value for the
property. For example, animation \texttt{right} moves
\texttt{box1} to the right:

\begin{js}
const right = new TweenMax("#box1", 1, { x: 50 });
\end{js}

A sequential animation is created by creating a timeline and \texttt{add}ing
animations to it.  Below, we create the animation \texttt{rightThenDown} which
moves \texttt{box1} to the right and then moves it down.

\begin{js}
const rightThenDown = new TimelineMax({ paused: true })
  .add(new TweenMax("#box1", 1, { x: 50 }))
  .add(new TweenMax("#box1", 1, { y: 50 }));
\end{js}


The \texttt{add} method takes the position on the timeline as an optional
paramter. Hence, if we position both animations at point \texttt{0} on the timeline,
they will run in parallel. For example, the \texttt{both} animation below 
moves both \texttt{box1} and \texttt{box2} in parallel to an \texttt{x}-value
of 50.

\begin{js}
const both = new TimelineMax({ paused: true })
  .add(new TweenMax("#box1", 1, { x: 50 }), 0)
  .add(new TweenMax("#box2", 1, { x: 50 }), 0);
\end{js}

Since we have specified the option \texttt{paused} with \texttt{true}, we must
call the \texttt{play} method to run an animation, as in
\texttt{both.play()}. Using this behaviour, and the ability to nest timelines,
we can provide the \dsl{} primitives.

\begin{js}
function sequential(tl1, tl2) {
  return new TimelineMax({ paused: true })
    .add(tl1.play())
    .add(tl2.play()); }

function parallel(tl1, tl2) {
  return new TimelineMax({ paused: true })
    .add(tl1.play(), 0)
    .add(tl2.play(), 0); }
\end{js}

\subsection{Callbacks and Inspectability}

GSAP also provides features related to inspectability. For example, we can use the
\texttt{totalDuration} method to return the total duration of an animation.
Animations created with the previously defined \texttt{sequential} and
\texttt{parallel} functions correctly give their total duration when queried.
For example, we define an animation which moves both boxes in parallel to
\texttt{x = 50} and then back to \texttt{x = 0} in parallel. The duration is
correctly returned as 2.

\begin{js}
const bothTo50 = parallel(
  new TweenMax("#box1", 1, { x: 50 }),
  new TweenMax("#box2", 1, { x: 50 }));

const bothTo0 = parallel(
  new TweenMax("#box1", 1, { x: 0 }),
  new TweenMax("#box2", 1, { x: 0 }));

const bothAnimation = sequential(bothTo50, bothTo0);
const bothAnimDuration = bothAnimation.totalDuration(); // = 2
\end{js}

However, if we want to provide animations similar to \hs{onlyDone}, which contains an \hs{if-then-else}, then the duration returned is not what we expect. The \texttt{add} method is overloaded to take a callback as parameter, which we used in the previous section since \texttt{tl.play()} is shorthand for the callback \texttt{() => tl.play()}. Using the callback parameter we can embed arbitrary effects and control flow. For example, we can create a conditional animation \texttt{condAnim}, for which a duration of 1 is returned.This is different from the expected total duration of the animation, which is 2. (Of course, in general the duration of the animations in both branches could differ, which is what makes it difficult to provide a procedure for calculating the duration of an animation in this form.)

\begin{js}
const condAnim = new TimelineMax({ paused: true })
  .add(bothTo50.play())
  .add(() => { if (cond) { bothTo0.play()   }
               else      { bothTo100.play() } });
const condAnimDuration = condAnim.totalDuration() // = 1
\end{js}

\subsection{Relevance of Duration in Other Features}

A wrongly calculated duration becomes more problematic when another feature relies on this calculation. The relative sequencing feature needs the duration of the first animation, so the second animation can be added with the correct offset. For example, we can specify the position parameter \texttt{-=0.5} to specify that it should start 0.5 seonds before the end of the previous animation.

\begin{js}
const bothDelayed = new TimelineMax({ paused: true })
  .add(new TweenMax("#box1", 1, { x: 50 }), 0)
  .add(new TweenMax("#box2", 1, { x: 50 }), "-=0.5");
\end{js}

This feature behaves somewhat unexpectedly when combined with a
conditional animation. In the \texttt{relativeCond} animation below we add a
basic animation followed by a conditional animation. Then we add an animation
with a relative position. The result is that the relative position is
calculated with respect to the duration of the animations before it, which was
a duration of 1.

\begin{js}
const relativeCond = new TimelineMax({ paused: true })
  .add(new TweenMax("#box1", 1, { x: 50 }), 0)
  .add(() => { if (cond) { new TweenMax("#box1", 1, { x: 100 });
               } else { new TweenMax("#box1", 1, { x: 0 }); } })
  .add(new TweenMax("#box2", 1, { x: 50 }), "-=0.5");
\end{js}

Predicting the resulting behavior becomes much more complicated when
conditional animations are embedded deep inside complex timelines and cause
erroneous duration calculations.  Clearly, being more explicit about control
flow structures and their impact on inspectability like in \dsl{} helps
providing more predictable interaction between these features.

\subsection{Relative Sequential Composition in \dsl{}}

While not yet ideal from a usability perspective,\footnote{It
requires
\hs{AllowAmbiguousTypes} (among other extensions) and explicitly instantiating the
constraint \hs{c} at the call-site.
}
 \dsl{} does enable correctly
specifying relative sequential compositions by means of \hs{relSequential}.
\begin{spec}
relSequential :: forall c g.
  (c (Const Duration), c g, Applicative g, Delay g) =>
  (forall f. c f => f ()) -> g () -> Float -> g ()
relSequential anim1 anim2 offset = let
  dur = getDuration (duration anim1)
  in anim1 `sequential` (delay (dur + offset) *> anim2)
\end{spec}

Because this definition requires instances instantiated with \hs{Const Duration},
it only works for animations whose duration can be analyzed. 
% Of course we can define a similar function, for example
% \hs{relMaxSequential}, which uses the maximum duration of an animation
% instead. 
Now, we can correctly compose conditional animations sequentially using
relative positioning. We use the \hs{relMaxSequential} function to sequence
animations with a maximum duration.

\begin{spec}
class (LinearTo Float f, IfThenElse f) => Combined f where
instance (LinearTo Float f, IfThenElse f) => Combined f where

relCond :: (LinearTo Float f, IfThenElse f, Applicative f) => f ()
relCond = relMaxSequential @Combined anim1 anim2 (-0.5)
\end{spec}


