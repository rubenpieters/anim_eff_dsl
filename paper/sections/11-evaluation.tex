\section{Interaction Between Callbacks and Inspectability}
\label{sec:evaluation}

There are many different JavaScript animation libraries\footnote{Some examples: \url{https://greensock.com}, \url{https://animejs.com/}, and \url{https://popmotion.io}.}. Many of these libraries provide callbacks to provide extensibility, by which the user can add custom behaviour the library has not foreseen. We take as representative example the GreenSock Animation Platform (GSAP), which is a widely recommended and mature JavaScript animation library providing a variety of features.

\subsection{Working with GSAP}

GSAP provides primitives which are similar to the \hs{linearTo} and \hs{sequential} operations in \dsl{}. While it does not have a primitive for \hs{parallel} composition, we can implement it using the features provided by GSAP.

In GSAP we can create \texttt{TweenMax} objects, which is the equivalent of the \hs{linearTo} operation. The arguments are also similar: a parameter which indicates which object to change, a duration, and the target value for the property. Below we create the animation \texttt{right} which moves \texttt{box1} to the right.

\begin{js}
const right = new TweenMax("#box1", 1, { x: 50 });
\end{js}

Constructing a sequential animation is done by using a timeline. First a timeline is created and we can add animations with the \texttt{add} method. Below, we create the animation \texttt{rightThenDown} which moves \texttt{box1} to the right and then moves it down.

\begin{js}
const rightThenDown = new TimelineMax({ paused: true })
  .add(new TweenMax("#box1", 1, { x: 50 }))
  .add(new TweenMax("#box1", 1, { y: 50 }));
\end{js}

To create an animation which moves both \texttt{box1} and \texttt{box2} in parallel to the right, we utilize the optional position parameter. If we provide both additions to the timeline with the same static position \texttt{0}, then both animations run in parallel. Below we create a \texttt{both} animation which moves both \texttt{box1} and \texttt{box2} in parallel to an \texttt{x}-value of 50.

\begin{js}
const both = new TimelineMax({ paused: true })
  .add(new TweenMax("#box1", 1, { x: 50 }), 0)
  .add(new TweenMax("#box2", 1, { x: 50 }), 0);
\end{js}

Since we have specified the option \texttt{paused} with \texttt{true}, we must call the \texttt{play} method to actually run the animation, for example \texttt{both.play()}. Using this behaviour, and the ability to nest timelines, we can extract similar functionality as \hs{sequential} and \hs{parallel} in \dsl{}.

\begin{js}
function sequential(tl1, tl2) {
  return new TimelineMax({ paused: true })
    .add(tl1.play())
    .add(tl2.play()); }

function parallel(tl1, tl2) {
  return new TimelineMax({ paused: true })
    .add(tl1.play(), 0)
    .add(tl2.play(), 0); }
\end{js}

\subsection{Callbacks and Inspectability}

The \texttt{add} methodis overloaded to also accept callbacks. We made use of this in the previous section, since \texttt{tl.play()} was shorthand for the callback \texttt{() => tl.play()}. This is how GSAP achieves extensibility, since these callbacks provides us with the capability of embedding arbitrary effects inside any animation.

GSAP also provides features related to inspectability. In fact, it provides a \texttt{totalDuration} method to return the total duration of an animation. However, callbacks and inspectability do not always work nicely together. This section illustrates an example of this.

Animations created with the previously defined \texttt{sequential} and \texttt{parallel} functions correctly give their total duration when queried. For example, we define an animation which moves both boxes in parallel to \texttt{x = 50} and then back to \texttt{x = 0} in parallel. The duration is correctly returned as 2.

\begin{js}
const bothTo50 = parallel(
  new TweenMax("#box1", 1, { x: 50 }),
  new TweenMax("#box2", 1, { x: 50 }));

const bothTo0 = parallel(
  new TweenMax("#box1", 1, { x: 0 }),
  new TweenMax("#box2", 1, { x: 0 }));

const bothAnimation = sequential(bothTo50, bothTo0);

const bothAnimDuration = bothAnimation.totalDuration()
// bothAnimDuration = 2
\end{js}

However, if we want to provide animations similar to \hs{onlyDone}, which contains an \hs{if-then-else} construction, then the duration returned is not what might be expected. For example, if we create a conditional animation \texttt{conditionalAnim}, then it returns a duration of 1. This is different from the expected total duration of the animation, which is 2. Of course, in general the duration of the animations in both branches could differ, which is what makes it difficult to provide a procedure for calculating the duration of an animation in this form.

\begin{js}
const conditionalAnim = new TimelineMax({ paused: true })
  .add(bothTo50.play())
  .add(() => { if (cond) { bothTo0.play()
               } else { bothTo100.play() } });

const conditionalAnimDuration = conditionalAnim.totalDuration()
// conditionalAnimDuration = 1
\end{js}

\subsection{Relevance of Duration in Other Features}

While this wrongly calculated duration might be annoying, by itself it is something that can be worked around. However, it becomes more problematic when other features rely on this duration calculation.

This is the case for adding animations with relative positions to timelines. Instead of adding animations to static positions in the timeline, they can be added relatively to the previous animation. For example, we can specify the position parameter \texttt{-=0.5} to specify that an animation should be started 0.5 seconds before the end of the last animation.

\begin{js}
const bothDelayed = new TimelineMax({ paused: true })
  .add(new TweenMax("#box1", 1, { x: 50 }), 0)
  .add(new TweenMax("#box2", 1, { x: 50 }), "-=0.5");
\end{js}

This feature behaves somewhat unexpectedly when combined with adding a conditional animation. In the below animation \texttt{relativeCond} we add a basic animation followed by a conditional animation. Then we add an animation with a relative position, the result is that the relative position is calculated with respect to the duration of the animations before it, which was a duration of 1.

\begin{js}
const relativeCond = new TimelineMax({ paused: true })
  .add(new TweenMax("#box1", 1, { x: 50 }), 0)
  .add(() => { if (cond) { new TweenMax("#box1", 1, { x: 100 });
               } else { new TweenMax("#box1", 1, { x: 0 }); } })
  .add(new TweenMax("#box2", 1, { x: 50 }), "-=0.5");
\end{js}

Predicting in what animations this behaviour results in becomes much more complicated when conditional animations are embedded deep inside complex timelines and cause erroneous duration calculations.

As a a result, being more conscious of control flow structures and their impact on inspectability such as in \dsl{} will help in providing more predictable interaction between these features.

\subsection{Relative Sequential Composition in \dsl{}}

\dsl{} enables you to correctly specify relative sequential composition, though the usability of the feature is not optimal yet. The definition for providing relative sequential composition is defined in \hs{relSequential}, for which we have to enable \hs{AllowAmbiguousTypes} (among other extensions) and pass the polymorphic constraint \hs{c} explicitly at the call-site.

\begin{spec}
relSequential :: forall c g.
  (c (Const Duration), c g, Applicative g) =>
  (forall f. c f => f ()) -> g () -> Float -> g ()
relSequential anim1 anim2 offset = let
  dur = getDuration (duration anim1)
  in anim1 `sequential` (delay (dur + offset) *> anim2)
\end{spec}

Since this definition requires instances instantiated with \hs{Const Duration}, this will only work for animations where the duration can be analyzed. Of course we can define a similar function, for example \hs{relMaxSequential}, which uses the maximum duration of an animation instead. Using this, we can correctly compose conditional animations sequentially using relative positioning.

\begin{spec}[mathescape=true]
class (LinearTo Float f, IfThenElse f) => Combined f where
instance (LinearTo Float f, IfThenElse f) => Combined f where

relCond :: (LinearTo Float f, IfThenElse f, Applicative f) => f ()
relCond = relMaxSequential @Combined anim1 anim2 (-0.5)
\end{spec}

